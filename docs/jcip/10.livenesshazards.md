# 避免活跃性危险 
- 死锁经典问题：哲学家就餐。解决方案：如果你不能同时获取两个筷子，那就放弃你的一个筷子。
- 数据库解决死锁：某个事务发生死锁（通过正在等待的有向图中搜索循坏链路），选择一个牺牲者，叫他放弃这个事务。
这个牺牲者释放的资源，就能打破死锁僵局。
- 所有线程以固定顺序获取锁，就不会出现锁顺序死锁的问题。
- 简单的锁顺序死锁例子。致命的拥抱：LeftRightDeadlock
- 当调用的方法不需要持有锁时，称为开放调用 Open Call。参阅 CooperatingNoDeadlock
- 活锁：线程活跃度失败的一种形式。没有被阻塞，不断重试相同的操作，却总是失败。
  - 随机等待一段时间再重试，或者放弃，都能有效避免活锁的发生。
- 开放调用，可以大大减少一个线程一次请求多个锁的情况。