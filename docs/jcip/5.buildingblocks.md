# 基础构建模块
- 同步容器的迭代器和ConcurrentModificationException：及时失败策略，察觉到被别人修改了，就果断报错。
  - 原理：使用modCount记录修改次数，迭代期间，如果发现该计数器数值变了，代表其他线程做出影响长度的修改，抛出CME。
- 迭代期间，对容器加锁的替代方法是复制容器。CopyOnWrite ?
- 同步容器对容器所有state进行串行访问，同步粒度过大，影响了并发性，也就是削弱了性能。
- JDK 5.0+引入并发容器，例如ConcurrentHashMap和CopyOnWriteArrayList，ConcurrentLinkedQueue
- JDK 6.0+引入ConcurrentSkipListMap和ConcurrentSkipListSet，作为对SortMap和SortSet的并发替代。
- JDK 7中，ConcurrentHashMap使用分段锁机制，每一段一个锁，支持有限数量的写线程并发修改。
  - 它的迭代器是弱一致性的，允许并发修改，可以（但不保证）能看到迭代器创建之后，容器的修改。
  - size的返回值是不精确的。
  - 具有原子操作：putIfAbsent，removeIfEqual，replaceIfEqual
  - 缺点：无法独占加锁。
- CopyOnWriteList：写时复制的迭代器返回的元素和迭代器创建时严格一致，不会考虑后续的修改。
- BlockingQueue 提供可阻塞的put和take方法，与定时的offer、poll是等价的。
- BlockingQueue 的实现有LinkedBlockingQueue、ArrayBlockingQueue和SynchronousQueue。
- 对象池拓展了连续的线程限制，将“对象”借给一个请求线程。
- 双端队列：JDK 6.0+新增Deque和Blocking1Queue。Deque是双端队列，实现为ArrayDeque和LinkedBlockingDeque。
- 工作窃取：一个消费者完成自身双端队列的任务后，可以去其他消费者的双端队列尾部偷任务。
- Thread 提供了中断机制。一个线程不能强迫其他线程停止正在做的事情，或者去做其他事情。
A中断B，仅仅代表A要求B在达成某个方便停止的关键点时，停止正在做的事情。
- 一个方法可以抛出InterruptedException时，代表这是一个可阻塞的方法。
- 响应中断的策略
  - 向上级传递InterruptedException
  - 捕获InterruptedException，在当前线程调用interrupt()恢复中断。恢复中断是为了不吞掉这个中断，避免掩盖中断。
  - 注意，不应该捕获它，然后什么都不做。
- synchronizer是一个对象，根据本身state调节线程控制流。
  - 阻塞队列可以扮演sync角色；其他synchronizer包括Semaphore（信号量）、barrier（关卡），latch（闭锁）。
  - sync封装state，决定着线程在某个时间点汇聚时，是通过或者等待。
- 闭锁（latch），可以延迟线程进度到终止状态。开始阀门能同时释放所有工作者线程，结束阀门可以等待最后一个线程执行完毕。
- FutureTask有三个state：等待，运行和完成。
- 信号量管理一个许可集。许可数量通过构造函数传入初始化。acquire请求许可，release释放许可。
- 信号量可以将任何容器转化为有界的阻塞容器。参阅 BoundedHashSet
- 应该在文档中注解某个类是否为线程安全。