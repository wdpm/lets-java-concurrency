## 对象的共享
- 锁代表着：同步/互斥(原子性) + 内存可见性。保证一个线程对数值的写入，其他线程都可见。
- volatile仅仅代表：内存可见性。
- 线程封闭：如果数据只在单线程中被访问，就不要任何的同步。线程封闭保证了原子性。
- 如果确保单一线程写入一个共享volatile变量i，那么i++也就是线程安全的。因为单一线程保证原子性，volatile本身提供可见性。
- ThreadLocal 确保线程封闭：get总是返回当前线程通过set设置的最新值。
- 不可变对象的性质
  - 它的state在创建后无法修改
  - 所有filed都是final
  - 它被正确地创建（创建时this没有逃逸出去）
- 最佳实践：将field设置为private，除非你想暴露它；将field设置为final，除非它是可变的。
- 如果final指向可变对象，访问这些对象的state时依然需要同步。
- 安全发布的模式：对象的引用和对象的state必须同时对其他线程可见
  - 静态初始化器初始化对象的引用
  - 将该引用保存到volatile或者AtomicReference的field
  - 将该引用保存到正确对象的final域中
  - 或者，将该引用保存到由锁保护的域中
- 静态发布：`public static Holder holder = new Holder(32);` JVM在类的初始化阶段执行，由JVM内在的同步保证安全发布。
- 共享对象的有效策略
  - 线程限制：只能被占有它的线程修改
  - 共享只读：任何线程都不能修改它
  - 共享线程安全：一个线程安全的对象在内部进行同步
  - 被守护：一个被守护的对象只能通过特定的锁来访问。