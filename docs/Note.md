# 笔记
- 线程安全的代码：管理state的访问，一般是可变、共享的状态。
  - 可变：变量的值可以更改
  - 共享：变量可以被多个线程访问
- 保证线程安全的方法
  - 不要跨线程共享变量
  - 使用不可变的state变量
  - 访问state变量时使用同步
---
- 类线程安全的定义：被多个线程访问时，类的行为依然正确。
- 线程安全的类已经封装了同步，客户端不需要自己提供。
- 无状态的对象永远线程安全。
- 为保证state一致性，需要在原子操作中更新相关联的state变量。
- java 强制原子性的内部锁机制：synchronized 块。
- 每个共享的state变量都需要唯一一个确定的锁来保护，维护者必须知道这个锁。
- 对于每一个涉及变量的不变约束，需要同一个锁保护其所有的变量。参阅 SynchronizedFactorizer
---
- 锁代表着：同步/互斥(原子性) + 内存可见性。保证一个线程对数值的写入，其他线程都可见。
- volatile仅仅代表：内存可见性。
- 线程封闭：如果数据只在单线程中被访问，就不要任何的同步。线程封闭保证了原子性。
- 如果确保单一线程写入一个共享volatile变量i，那么i++也就是线程安全的。因为单一线程保证原子性，volatile本身提供可见性。
- ThreadLocal 确保线程封闭：get总是返回当前线程通过set设置的最新值。
- 不可变对象的性质
  - 它的state在创建后无法修改
  - 所有filed都是final
  - 它被正确地创建（创建时this没有逃逸出去）
- 最佳实践：将field设置为private，除非你想暴露它；将field设置为final，除非它是可变的。
- 如果final指向可变对象，访问这些对象的state时依然需要同步。
- 安全发布的模式
  - 